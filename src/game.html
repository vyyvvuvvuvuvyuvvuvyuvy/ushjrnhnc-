<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Minecraft Infinite World</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background-color: #87ceeb;
      cursor: crosshair;
    }
    #menu {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      text-align: center;
      color: white;
      text-shadow: 1px 1px 3px black;
      user-select: none;
    }
    #menu h1 {
      font-size: 3rem;
      margin: 0 0 10px;
      color: #4caf50;
    }
    #createWorldBtn {
      font-size: 1.2rem;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background-color: #4caf50;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #createWorldBtn:hover {
      background-color: #388e3c;
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 1rem;
      text-shadow: 1px 1px 3px black;
      user-select: none;
      z-index: 10;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>Minecraft</h1>
    <button id="createWorldBtn">Create World</button>
  </div>
  <div id="instructions">
    Click on the canvas to lock mouse and control camera. Use WASD to move.
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script> <!-- For noise -->

  <script>
    // Basic constants
    const CHUNK_SIZE = 16;
    const BLOCK_SIZE = 1;
    const RENDER_DISTANCE = 3; // Number of chunks to load around player

    // Textures URLs you provided
    const textureURLs = {
      dirt: 'https://protoinfrastack.ivondy.com/media/agYI9SMxqBwFj8qNVD9ur5t5KRgrC5s1RCc0',
      wood: 'https://protoinfrastack.ivondy.com/media/ksvRf2rUmXAwQZBqbCdZDQ9a20C7y7NQOvT9',
      leaves: 'https://protoinfrastack.ivondy.com/media/KNBCA1pHmXJaefhA8gCOr5S9oDJdMpq5MTlL',
      grass: 'https://protoinfrastack.ivondy.com/media/MM4IZLXA8a2PjVeOVfw1K3mZ8TDbaLTcNPJr',
      stone: 'https://protoinfrastack.ivondy.com/media/HlWZFzA92NXgqP3V3LxXV0ca3QyUEKzmjhuo'
    };

    // Three.js essentials
    let scene, camera, renderer, controls;
    let materials = {};
    let cubeGeometry;
    let blocks = new Map(); // Map of blocks by "x,y,z" key
    let chunks = new Map(); // Map of chunks by "cx,cz" key

    // Movement and timing
    const move = { forward: false, backward: false, left: false, right: false };
    let velocity = new THREE.Vector3();
    const speed = 5;
    let prevTime = performance.now();

    // Noise for terrain generation
    const simplex = new SimplexNoise();

    // Helper: create key strings
    function blockKey(x,y,z) { return `${x},${y},${z}`; }
    function chunkKey(cx, cz) { return `${cx},${cz}`; }

    // Load textures with nearest filter for pixelated look
    function loadTexture(url) {
      const tex = new THREE.TextureLoader().load(url);
      tex.magFilter = THREE.NearestFilter;
      tex.minFilter = THREE.NearestFilter;
      return tex;
    }

    function initMaterials() {
      materials.dirt = new THREE.MeshLambertMaterial({ map: loadTexture(textureURLs.dirt) });
      materials.wood = new THREE.MeshLambertMaterial({ map: loadTexture(textureURLs.wood) });
      materials.leaves = new THREE.MeshLambertMaterial({ map: loadTexture(textureURLs.leaves), transparent: true });
      materials.grass = new THREE.MeshLambertMaterial({ map: loadTexture(textureURLs.grass) });
      materials.stone = new THREE.MeshLambertMaterial({ map: loadTexture(textureURLs.stone) });
    }

    // Initialize scene and Three.js stuff
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 10, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.PointerLockControls(camera, document.body);
      document.body.addEventListener('click', () => {
        controls.lock();
      });

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      cubeGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('pointerdown', onPointerDown);

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
    }

    // Add a block mesh and store it
    function addBlock(x, y, z, type) {
      const material = materials[type] || materials.grass;
      const mesh = new THREE.Mesh(cubeGeometry, material);
      mesh.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
      scene.add(mesh);
      const key = blockKey(x,y,z);
      blocks.set(key, { x, y, z, type, mesh });
    }

    // Remove all blocks in a chunk
    function removeChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      if (!chunks.has(key)) return;
      const chunkBlocks = chunks.get(key);
      chunkBlocks.forEach(({mesh}) => {
        scene.remove(mesh);
        blocks.delete(blockKey(mesh.position.x / BLOCK_SIZE, mesh.position.y / BLOCK_SIZE, mesh.position.z / BLOCK_SIZE));
      });
      chunks.delete(key);
    }

    // Generate terrain height using noise
    function getHeight(x, z) {
      const scale = 0.1;
      const noiseVal = simplex.noise2D(x * scale, z * scale);
      return Math.floor((noiseVal + 1) / 2 * 3) + 1;
    }

    // Generate a chunk at chunk coords cx, cz
    function generateChunk(cx, cz) {
      const chunkBlocks = [];
      const startX = cx * CHUNK_SIZE;
      const startZ = cz * CHUNK_SIZE;

      for(let x=0; x < CHUNK_SIZE; x++) {
        for(let z=0; z < CHUNK_SIZE; z++) {
          const worldX = startX + x;
          const worldZ = startZ + z;
          const height = getHeight(worldX, worldZ);

          for(let y = 0; y <= height; y++) {
            let type = 'dirt';
            if (y === height) type = 'grass';
            else if (y < height - 1) type = 'stone';
            addBlock(worldX, y, worldZ, type);
            chunkBlocks.push(blocks.get(blockKey(worldX, y, worldZ)));
          }

          if (Math.random() < 0.05) {
            createTree(worldX, height + 1, worldZ, chunkBlocks);
          }
        }
      }

      chunks.set(chunkKey(cx, cz), chunkBlocks);
    }

    // Create a simple tree (trunk + leaves)
    function createTree(x, y, z, chunkBlocks) {
      const trunkHeight = 3 + Math.floor(Math.random() * 3);
      for(let i=0; i < trunkHeight; i++) {
        addBlock(x, y + i, z, 'wood');
        chunkBlocks.push(blocks.get(blockKey(x, y + i, z)));
      }
      const leafStartY = y + trunkHeight;
      for(let dx = -1; dx <= 1; dx++) {
        for(let dy = 0; dy <= 2; dy++) {
          for(let dz = -1; dz <= 1; dz++) {
            if(dx === 0 && dy === 0 && dz === 0) continue;
            addBlock(x + dx, leafStartY + dy, z + dz, 'leaves');
            chunkBlocks.push(blocks.get(blockKey(x + dx, leafStartY + dy, z + dz)));
          }
        }
      }
    }

    // Load chunks around player
    function updateChunks() {
      const playerPos = controls.getObject().position;
      const currentChunkX = Math.floor(playerPos.x / (CHUNK_SIZE * BLOCK_SIZE));
      const currentChunkZ = Math.floor(playerPos.z / (CHUNK_SIZE * BLOCK_SIZE));

      const neededChunks = new Set();

      for(let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
        for(let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
          const cx = currentChunkX + dx;
          const cz = currentChunkZ + dz;
          neededChunks.add(chunkKey(cx, cz));
          if (!chunks.has(chunkKey(cx, cz))) {
            generateChunk(cx, cz);
          }
        }
      }

      for (let key of chunks.keys()) {
        if (!neededChunks.has(key)) {
          const [cx, cz] = key.split(',').map(Number);
          removeChunk(cx, cz);
        }
      }
    }

    // Find block by mesh
    function findBlockByMesh(mesh) {
      const pos = mesh.position;
      return blocks.get(blockKey(pos.x / BLOCK_SIZE, pos.y / BLOCK_SIZE, pos.z / BLOCK_SIZE));
    }

    // Replace block type and update material
    function replaceBlock(block, newType) {
      block.type = newType;
      block.mesh.material = materials[newType] || materials.grass;
    }

    // Digging mechanic: click grass block -> replace with stone block
    function onPointerDown(event) {
      event.preventDefault();
      if (!controls.isLocked) return;

      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(Array.from(blocks.values()).map(b => b.mesh));
      if (intersects.length > 0) {
        const intersected = intersects[0].object;
        const block = findBlockByMesh(intersected);

        if (block) {
          if (block.type === 'grass') {
            replaceBlock(block, 'stone');
          }
        }
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      switch(event.code) {
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
      }
    }

    function onKeyUp(event) {
      switch(event.code) {
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      if (controls.isLocked) {
        const time = performance.now();
        const delta = (time - prevTime) / 1000;

        velocity.set(0, 0, 0);
        if (move.forward) velocity.z -= speed * delta;
        if (move.backward) velocity.z += speed * delta;
        if (move.left) velocity.x -= speed * delta;
        if (move.right) velocity.x += speed * delta;

        controls.moveRight(velocity.x);
        controls.moveForward(velocity.z);

        updateChunks();

        prevTime = time;
      } else {
        prevTime = performance.now();
      }

      renderer.render(scene, camera);
    }

    // Fix applied here: call updateChunks immediately after resetting world and player position
    function createWorld() {
      blocks.forEach(({mesh}) => scene.remove(mesh));
      blocks.clear();
      chunks.clear();

      camera.position.set(0, 10, 0);
      controls.getObject().position.copy(camera.position);

      updateChunks(); // <-- Important: load initial chunks immediately
    }

    // Initialization
    initMaterials();
    init();
    animate();

    document.getElementById('createWorldBtn').addEventListener('click', () => {
      createWorld();
    });
  </script>
</body>
</html>

